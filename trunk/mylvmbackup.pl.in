#!/usr/bin/perl  -w
#
# mylvmbackup - utility for creating MySQL backups via LVM snapshots
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use DBI;
use Getopt::Long;
use Config::IniFiles;
use strict;
use diagnostics;

# Initialize config file
my $cfg = new Config::IniFiles( -file => "/etc/mylvmbackup.conf" );

# Version is set in the Makefile
my $version='@VERSION@';

my $user = $cfg->val( 'auth', 'user');
my $password = $cfg->val ('auth', 'password');
my $host = $cfg->val ('auth', 'host');
my $port = $cfg->val ('auth', 'port');
my $socket = $cfg->val ('auth', 'socket');

my $need_xfsworkaround=$cfg->val ('fs', 'is_xfs');

my $vgname=$cfg->val ('lvm', 'vg_src_name');
my $prefix=$cfg->val ('lvm', 'prefix');
my $lvname=$cfg->val ('lvm', 'lv_src_name');
my $datefmt=$cfg->val ('misc', 'date_format');

# Not used at the moment, not in GetOptions
my $relpath=$cfg->val ('fs', 'rel_path');

my $lvsize=$cfg->val ('lvm', 'snapshot_size');
my $tararg=$cfg->val ('misc', 'tar_opts');

my $mountdir=$cfg->val ('fs', 'mount_dir');
my $backupdir=$cfg->val ('fs', 'backup_dir');

my $lvcreate=$cfg->val ('bin', 'lvcreate_bin');
my $lvremove=$cfg->val ('bin', 'lvremove_bin');
my $mount=$cfg->val ('bin', 'mount_bin');
my $umount=$cfg->val ('bin', 'umount_bin');
my $tar=$cfg->val ('bin', 'tar_bin');

my $backuplv = $cfg->val ('lvm', 'lv_backup_name');

GetOptions("user=s" => \$user,
  "host=s" => \$host,
  "socket=s" => \$socket,
  "port=i" => \$port,
  "password=s" => \$password,
  "vgname=s" => \$vgname,
  "lvsize=s" => \$lvsize,
  "lvname=s" => \$lvname,
  "backuplv=s" => \$backuplv,
  "prefix=s" => \$prefix,
  "mountdir=s" => \$mountdir,
  "backupdir=s" => \$backupdir,
  "lvcreate=s" => \$lvcreate,
  "lvremove=s" => \$lvremove,
  "mount=s" => \$mount,
  "umount=s" => \$mount,
  "tar=s" => \$mount,
  "tararg=s" => \$tararg,
  "datefmt=s" => \$datefmt,
  "xfs" => \&need_xfsworkaround,
  "help" => \&help,  
) or help();

$backuplv = $lvname.'_snapshot' if length($backuplv) == 0;

my $date=`/bin/date +"$datefmt"`;
chomp $date;
my $pos_filename = $backupdir.'/'.$prefix.'-'.$date.'_mysql.pos';
my $archivename  = $backupdir.'/'.$prefix.'-'.$date.'_mysql.tar.gz';

my $mounted = 0;
my $snapshot_created = 0;

# Check the backupdir, it must exist, and it must be readable/writable
check_dir($backupdir,'backupdir');

# Check the mountdir, it must exist, and be readable/writeable
check_dir($mountdir,'mountdir');

# Append the prefix to the mountdir, to allow multiple parallel backups
# the / is to ensure we go a level under it.
$mountdir .= '/'.$prefix;

# Now create it
mkdir $mountdir;

# Check it again for existence and read/write.
check_dir($mountdir,'mountdir');

# Now make sure it's empty
my @mountdir_content = glob "$mountdir/*" ;
unless ( scalar(@mountdir_content) eq 0)
{
	print "Please make sure Temp dir ($mountdir) is empty\n",'-'x20,"\n"; 
	exit(1);
};

# Figure out our DSN string
my $dsn = "dbi:mysql:mysql";
if(length($socket) > 0 && length($host) > 0) {
	print "Please specify only a host OR a socket to use.\n";
	exit(1);
}
if(length($socket) > 0) {
 $dsn .= "mysql_socket=".$socket;
}
if(length($host) > 0) {
 $dsn .= "host=".$host;
 $dsn .= "post=".$port;
}

print scalar(localtime)." Connecting to database...\n";
my $dbh= DBI->connect($dsn,$user,$password)
  or die $DBI::errstr;

print scalar(localtime). " Flushing tables...\n";
$dbh->do("flush tables with read lock") or die $DBI::errstr;

print scalar(localtime). " Taking position record...\n";
&create_pos_file($dbh);

print scalar(localtime). " Taking snapshot...\n";
create_snapshot();

print scalar(localtime). " Unlocking tables...\n";
$dbh->do("unlock tables") or die $DBI::errstr;

print scalar(localtime). " Disconnecting from database...\n";
$dbh->disconnect;

if ($snapshot_created)
{
	print scalar(localtime). " Mounting snapshot...\n";
	if (mount_snapshot())
	{
		print scalar(localtime). " Taking actual backup...\n";
		do_backup();
	}    
}

print scalar(localtime). " Cleaning up...\n";
cleanup();
exit 0;

sub create_pos_file
{
 my $dbh = shift;
 my $pos_file;
 open $pos_file, ">$pos_filename" or die ("Cannot open $pos_filename for write");
 &_create_pos_file_single($dbh,'SHOW MASTER STATUS',$pos_file,'Master');
 &_create_pos_file_single($dbh,'SHOW SLAVE STATUS',$pos_file,'Slave');
 close $pos_file;
}

sub _create_pos_file_single
{
	my $dbh = shift; my $query = shift; my $fh = shift; my $pos_prefix = shift;
	my $sth = $dbh->prepare($query) or die $DBI::errstr;
	$sth->execute or die $DBI::errstr;
	while (my $r = $sth->fetchrow_hashref) {
		foreach my $f (@{$sth->{NAME}}) {
			my $v = $r->{$f};
			$v = '' if (!defined($v));
			my $line = "$pos_prefix:$f=$v\n";
			print $fh $line;
		}
 }
 $sth->finish;
}

sub do_backup
{
  print "Create archive $archivename\n";
  my $command = "$tar $tararg $archivename $mountdir/$relpath/mysql";
  $command .= " $pos_filename" if (-f $pos_filename );
  if ( system($command) == 0 )
  {
    print "DONE\n";
  } else {
    print "FAIL $!\n";
  }    
}

sub mount_snapshot
{ 
  my $params = 'ro';
  $params .= ',nouuid' if $need_xfsworkaround;
  $mounted = 1 if (system("$mount -o $params /dev/$vgname/$backuplv $mountdir") == 0);
  print "Cannot mount snapshot: $! \n" unless $mounted eq 1;
  return $mounted; 
} 

sub create_snapshot 
{ 
  $snapshot_created=1 if 
   ( system("$lvcreate",'-s',"--size=$lvsize",
            "--name=$backuplv","/dev/$vgname/$lvname") == 0); 
  print "Cannot create snapshot: $! \n" unless $snapshot_created eq 1;
  return $snapshot_created;
}

sub cleanup
{
  system("$umount $mountdir") if ($mounted);
  unlink $pos_filename;
  system("$lvremove -f /dev/$vgname/$backuplv") if ($snapshot_created);
}

sub need_xfsworkaround {
	$need_xfsworkaround = 1;
}

sub help {
print <<EOF;

mylvmbackup Version $version
 
This script performs a MySQL backup by using an LVM snapshot volume.
It requires the MySQL server's data directory to be placed on a logical
volume, and creates an LVM snapshot to create a copy of the MySQL datadir.
Afterwards, all data files are backed using GNU tar to an archive directory.
See the manual page for more info.
 
Options:

  --user=<username>        MySQL username (def: $user)
  --password=<password>    MySQL password
  --host=<host>            Hostname for MySQL
  --port=<port>            TCP port for MySQL
  --socket=<socket>        UNIX socket for MySQL
  --lvcreate=<filename>    Path for lvcreate (def: $lvcreate)
  --lvremove=<filename>    Path for lvremove (def: $lvremove)
  --vgname=<name>          VG containing datadir (def: $vgname)
  --lvname=<name>          LV containing datadir (def: $lvname)
  --relpath=<name>         Relative path on LV to datadir (def: $relpath)
  --lvsize=<size>          Size for snapshot volume (def: $lvsize)
  --prefix=<prefix>        Prefix for naming the backup (def: $prefix)
  --datefmt=<format>       Specify the format of the date string (def: $datefmt)
  --mountdir=<dirname>     Path for mountpoint (def: $mountdir)
  --backupdir=<dirname>    Path for archives (def: $backupdir)
  --mount=<filename>       Path for mount (def: $mount)
  --umount=<filename>      Path for umount (def: $umount)
  --tar=<filename>         Path for tar (def: $tar)
  --xfs                    Use nouuid to safely mount XFS partitions.
  --help                   Print this help

If your MySQL daemon is not listening on localhost, or using the default 
socket location, you must specify --host or --socket.

EOF
 exit 1;
}

sub check_dir 
{
 my ($dirname,$optioname) = @_;
 unless ( (-d $dirname) and 
     (-w $dirname) and (-r $dirname) and  (-x $dirname))
 {
   print <<DIRERROR;

The directory $dirname does not exist or I don't have 
sufficient privileges to read/write/access it.
Please verify the permissions or provide another directory 
by using the option --$optioname=<directory>

DIRERROR
   &help;
  }
}  

