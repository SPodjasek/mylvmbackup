#!/usr/bin/perl  -w
#
# mylvmbackup - utility for creating MySQL backups via LVM snapshots
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package mylvmbackup;
use Config::IniFiles;
use Date::Format;
use DBI;
use File::Basename;
use Getopt::Long;

use diagnostics;
use strict;

# Version is set from the Makefile
my $version='@VERSION@';

# syslog-related options
my $syslog_ident = 'mylvmbackup';
my $syslog_args = 'pid,ndelay';
my $configfile = "/etc/mylvmbackup.conf";
my $configfile2 = "";

my $backupdir;
my $backuplv;
my $datefmt;
my $host;
my $innodb_recover;
my $lvcreate;
my $lvname;
my $lvremove;
my $lvs;
my $lvsize;
my $mount;
my $mysqld_safe;
my $mountdir;
my $need_xfsworkaround;
my $password;
my $port;
my $prefix;
my $relpath;
my $socket;
my $tar;
my $tararg;
my $umount;
my $user;
my $vgname;
my $log_method;
my $syslog_socktype;
my $syslog_facility;
my $syslog_remotehost;

# Load defaults into variables
load_defaults();
# Initialize variables from config file, if it exists
if (-r $configfile) {
  load_config($configfile);
}
# Load the commandline arguments
load_args();
# If they specified an alternative config file
if ($configfile2 ne "") {
  die ("Unable to load specified config file: $!\n") unless (-r $configfile2);
  load_config($configfile2);
  # re-load the arguments, as they should override any config file settings
  load_args();
}   

if ("$log_method" eq "syslog") {
  use Sys::Syslog qw(:DEFAULT setlogsock :macros);
  if ($syslog_socktype ne "native") {
    die ("You need to provide syslog_remotehost!\n") unless ($syslog_remotehost);
    setlogsock ($syslog_socktype);
    $Sys::Syslog::host = $syslog_remotehost;
  }
  openlog ($syslog_ident, $syslog_args, $syslog_facility);
  log_msg ("Starting new backup...", LOG_INFO);
}

my $lvm_version = lvm_version();

if ($innodb_recover == 1 && $lvm_version =~ /^1/)
{
  log_msg("LVM1 does not support writable snapshots. InnoDB recovery has been disabled.", LOG_INFO); 
  $innodb_recover=0;
}

# Clean up directory inputs
$prefix = clean_dirname($prefix);
$mountdir = clean_dirname($mountdir);
$backupdir = clean_dirname($backupdir);

# Validate the existence of a prefix
die "You must specify a non-empty prefix to name your backup!\n" unless ($prefix ne "");

$backuplv = $lvname.'_snapshot' if length($backuplv) == 0;

my $topmountdir = $mountdir;

my $posdir = $backupdir.'/pos';

my $date= time2str($datefmt, time);
my $pos_filename = $posdir.'/'.$prefix.'-'.$date.'_mysql.pos';
my $archivename  = $backupdir.'/'.$prefix.'-'.$date.'_mysql.tar.gz';

my $mounted = 0;
my $posmounted = 0;
my $snapshot_created = 0;

# Check the backupdir, it must exist, and it must be readable/writable
check_dir($backupdir,'backupdir');

# Ensure sub-directory for position file exists. Old position files can be
# ignored, hence we do not check for them.
mkdir $posdir;

# Check the mountdir, it must exist, and be readable/writeable
check_dir($mountdir,'mountdir');

# Append the prefix to the mountdir, to allow multiple parallel backups. The
# extra / is to ensure we go a level under it. An empty prefix is disallowed.
$mountdir .= '/'.$prefix;

my $posmountdir = $mountdir;
$posmountdir .= '-pos'; # Notice that we do not add a slash.

# Now create it
mkdir $mountdir;
mkdir $posmountdir;

# Check it again for existence and read/write.
check_dir($mountdir,'mountdir');

# Now make sure it's empty
my @mountdir_content = glob "$mountdir/*" ;
unless ( scalar(@mountdir_content) eq 0)
{
	log_msg ("Please make sure Temp dir ($mountdir) is empty.", LOG_ERR); 
	exit(1);
};

# Figure out our DSN string
my $dsn = "DBI:mysql:database=mysql";
if(length($socket) > 0 && length($host) > 0) {
	log_msg ("Please specify only a host OR a socket to use.", LOG_ERR);
	exit(1);
}
if(length($socket) > 0) {
 $dsn .= ";mysql_socket=".$socket;
}
if(length($host) > 0) {
 $dsn .= ";host=".$host;
}
if(length($port) > 0) {
 $dsn .= ";port=".$port;
}

log_msg ("Connecting to database...", LOG_INFO);
my $dbh= DBI->connect($dsn,$user,$password)
  or log_msg ($DBI::errstr, LOG_ERR) && die $DBI::errstr;

log_msg ("Flushing tables...", LOG_INFO);
$dbh->do("flush tables with read lock") 
  or log_msg ($DBI::errstr, LOG_ERR) && die $DBI::errstr;

log_msg ("Taking position record...", LOG_INFO);
&create_pos_file($dbh);

log_msg ("Taking snapshot...", LOG_INFO);
create_snapshot();

log_msg ("Unlocking tables...", LOG_INFO);
$dbh->do("unlock tables") 
  or log_msg ($DBI::errstr, LOG_ERR) && die $DBI::errstr;

log_msg ("Disconnecting from database...", LOG_INFO);
$dbh->disconnect;

if ($snapshot_created)
{
  log_msg ("Mounting snapshot...", LOG_INFO);
  if (mount_snapshot() and mount_posdir_bind())
  {
    if ($innodb_recover == 1)
    {
      log_msg ("Recovering innodb...", LOG_INFO);
      do_innodb_recover();
    }
    log_msg ("Taking actual backup...", LOG_INFO);
    do_backup();
  }    
}

log_msg ("Cleaning up...", LOG_INFO);
cleanup();
exit 0;

sub load_config 
{
  my $configfile = shift(@_);
  my $cfg = new Config::IniFiles( -file => $configfile )
    or log_msg ("Couldn't read configuration file: " . $!, 'LOG_WARNING');

  $user = $cfg->val( 'mysql', 'user', $user);
  $password = $cfg->val ('mysql', 'password', $password);
  $host = $cfg->val ('mysql', 'host', $host);
  $port = $cfg->val ('mysql', 'port', $port);
  $socket = $cfg->val ('mysql', 'socket', $socket);
  $mysqld_safe = $cfg->val ('mysql', 'mysqld_safe', $mysqld_safe);

  $need_xfsworkaround=$cfg->val ('fs', 'xfs', $need_xfsworkaround);

  $vgname=$cfg->val ('lvm', 'vgname', $vgname);
  $prefix=$cfg->val ('misc', 'prefix', $prefix);
  $lvname=$cfg->val ('lvm', 'lvname', $lvname);
  $datefmt=$cfg->val ('misc', 'datefmt', $datefmt);
  $innodb_recover=$cfg->val ('misc', 'innodb_recover', $innodb_recover);

  $relpath=$cfg->val ('fs', 'relpath', $relpath);

  $lvsize=$cfg->val ('lvm', 'lvsize', $lvsize);
  $tararg=$cfg->val ('misc', 'tararg', $tararg);

  $mountdir=$cfg->val ('fs', 'mountdir', $mountdir);
  $backupdir=$cfg->val ('fs', 'backupdir', $backupdir);

  $lvcreate=$cfg->val ('tools', 'lvcreate', $lvcreate);
  $lvremove=$cfg->val ('tools', 'lvremove', $lvremove);
  $lvs=$cfg->val ('tools', 'lvs', $lvs);
  $mount=$cfg->val ('tools', 'mount', $mount);
  $tar=$cfg->val ('tools', 'tar', $tar);
  $umount=$cfg->val ('tools', 'umount', $umount);

  $backuplv = $cfg->val ('lvm', 'backuplv', $backuplv);

  $log_method = $cfg->val('logging', 'log_method', $log_method);
  $syslog_socktype = $cfg->val ('logging', 'syslog_socktype', $syslog_socktype);
  $syslog_facility = $cfg->val ('logging', 'syslog_facility', $syslog_facility);
  $syslog_remotehost = $cfg->val ('logging', 'syslog_remotehost', $syslog_remotehost);
}

sub load_args
{
  GetOptions(
    "backupdir=s" => \$backupdir,
    "backuplv=s" => \$backuplv,
    "datefmt=s" => \$datefmt,
    "help" => \&help,  
    "host=s" => \$host,
    "innodb_recover" => \&innodb_recover,
    "lvcreate=s" => \$lvcreate,
    "lvname=s" => \$lvname,
    "lvremove=s" => \$lvremove,
    "lvs=s" => \$lvs,
    "lvsize=s" => \$lvsize,
    "mountdir=s" => \$mountdir,
    "mount=s" => \$mount,
    "password=s" => \$password,
    "port=i" => \$port,
    "prefix=s" => \$prefix,
    "relpath=s" => \$relpath,
    "socket=s" => \$socket,
    "tararg=s" => \$tararg,
    "tar=s" => \$tar,
    "umount=s" => \$umount,
    "user=s" => \$user,
    "vgname=s" => \$vgname,
    "xfs" => \&need_xfsworkaround,
    "log_method=s" => \$log_method,
    "syslog_socktype=s" => \$syslog_socktype,
    "syslog_facility=s" => \$syslog_facility,
    "syslog_remotehost=s" => \$syslog_remotehost,
    "configfile=s" => \$configfile2,
  ) or help();
}

sub load_defaults
{
  $user = 'root';
  $password = '';
  $host = '';
  $port = 3306;
  $socket = '';

  $need_xfsworkaround=0;

  $innodb_recover=0;

  $vgname='mysql';
  $prefix='backup';
  $lvname='data';
  $datefmt='%Y%m%d_%H%M%S';

  $relpath='';
  $lvsize='5G';
  $tararg='cvzf';

  $mountdir='/var/tmp/mylvmbackup/mnt/';
  $backupdir='/var/tmp/mylvmbackup/backup/';

  $lvcreate='lvcreate';
  $lvremove='lvremove';
  $lvs='lvs';
  $mount='mount';
  $umount='umount';
  $tar='tar';
  $mysqld_safe='mysqld_safe';

  $backuplv = '';

  $log_method = 'console';
  $syslog_socktype = 'native';
  $syslog_facility = '';
  $syslog_remotehost = '';
}

sub create_pos_file
{
 my $dbh = shift;
 my $pos_file;
 open $pos_file, ">$pos_filename" or log_msg ("Cannot open $pos_filename for write", LOG_ERR) && die ("Cannot open $pos_filename for write");
 &_create_pos_file_single($dbh,'SHOW MASTER STATUS',$pos_file,'Master');
 &_create_pos_file_single($dbh,'SHOW SLAVE STATUS',$pos_file,'Slave');
 close $pos_file;
}

sub _create_pos_file_single
{
	my $dbh = shift; my $query = shift; my $fh = shift; my $pos_prefix = shift;
	my $sth = $dbh->prepare($query) or log_msg ($DBI::errstr, LOG_ERR) && die $DBI::errstr;
	$sth->execute or log_msg ($DBI::errstr, LOG_ERR) && die $DBI::errstr;
	while (my $r = $sth->fetchrow_hashref) {
		foreach my $f (@{$sth->{NAME}}) {
			my $v = $r->{$f};
			$v = '' if (!defined($v));
			my $line = "$pos_prefix:$f=$v\n";
			print $fh $line;
		}
 }
 $sth->finish;
}

sub do_backup
{
  log_msg ("Creating archive $archivename", LOG_INFO);
  my $mountdir_rel = $mountdir;
  $mountdir_rel =~ s/^$topmountdir//g;
  $mountdir_rel =~ s/^\/+//g;
  my $pos_filename_rel = $posmountdir . '/' . File::Basename::basename($pos_filename);
  $pos_filename_rel =~ s/^$topmountdir//g;
  $pos_filename_rel =~ s/^\/+//g;
  my $command = "$tar $tararg $archivename -C $topmountdir $mountdir_rel/$relpath";
  $command .= " $pos_filename_rel" if (-f $pos_filename );
  if ( system($command) == 0 )
  {
    log_msg ("DONE", LOG_INFO);
  } else {
    log_msg ("FAIL $!", LOG_ERR);
  }    
}

sub mount_snapshot
{ 
  my $params = 'ro';
  $params = 'rw' if $innodb_recover;

  $params .= ',nouuid' if $need_xfsworkaround;
  $mounted = 1 if (system("$mount -o $params /dev/$vgname/$backuplv $mountdir") == 0);
  log_msg ("Cannot mount snapshot: $!", LOG_ERR) unless $mounted eq 1;
  return $mounted; 
}

sub do_innodb_recover
{
  if ( system("echo 'select 1;' | $mysqld_safe --datadir=$mountdir --skip-networking --skip-grant --bootstrap") != 0 )
  {
    log_msg ("Failed to perform InnoDB recovery on the snapshot!", LOG_ERR);
  }
}

sub mount_posdir_bind
{
  $posmounted = 1 if(system("$mount -o bind,ro $posdir $posmountdir") == 0);
  log_msg ("Cannot bind-mount position directory: $1", LOG_ERR) unless $posmounted eq 1;
  return $posmounted;
}

sub create_snapshot 
{ 
  $snapshot_created=1 if 
   ( system("$lvcreate",'-s',"--size=$lvsize",
            "--name=$backuplv","/dev/$vgname/$lvname") == 0); 
  log_msg ("Cannot create snapshot: $!", LOG_ERR) unless $snapshot_created eq 1;
  return $snapshot_created;
}


sub log_msg
{
  my $msg = shift;
  my $syslog_level = shift;

  if ($log_method eq "console") {
    __print_it($syslog_level, $msg);
  } elsif ($log_method eq "syslog") {
    __log_it ($syslog_level, $msg);
  } elsif ($log_method eq "both") {
    __print_it ($syslog_level, $msg);
    __log_it ($syslog_level, $msg);
}

  sub __print_it
  {
    my $syslog_level = shift;
    my $msg = shift;
    my $logmsg = '';

  if ($syslog_level eq LOG_WARNING) {
      $logmsg = " Warning: ";
    } elsif ($syslog_level eq LOG_INFO) {
      $logmsg = " Info: ";
    } elsif ($syslog_level eq LOG_ERR) {
      $logmsg = " Error: ";
    }
    print timestamp() . $logmsg . $msg . "\n";
  }

  sub __log_it { syslog ($_[0], $_[1]); }

  sub timestamp { return ymd() . " " . hms(); }

  sub hms
  {
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
    return sprintf("%02d:%02d:%02d", $hour, $min, $sec);
  }

  sub ymd
  {
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
    return sprintf("%04d%02d%02d", $year+1900, $mon+1, $mday);
  }
}


sub cleanup
{
  system("$umount $mountdir") if ($mounted);
  system("$umount $posmountdir") if ($posmounted);
  unlink $pos_filename;
  rmdir $mountdir;
  rmdir $posmountdir;
  rmdir $posdir;
  system("$lvremove -f /dev/$vgname/$backuplv") if ($snapshot_created);
}

sub innodb_recover {
	$innodb_recover = 1;
}

sub need_xfsworkaround {
	$need_xfsworkaround = 1;
}

sub help {
print <<EOF;

mylvmbackup Version $version
 
This script performs a MySQL backup by using an LVM snapshot volume.
It requires the MySQL server's data directory to be placed on a logical
volume, and creates an LVM snapshot to create a copy of the MySQL datadir.
Afterwards, all data files are backed using GNU tar to an archive directory.
See the manual page for more info.
 
Options:

  --user=<username>             MySQL username (def: $user)
  --password=<password>         MySQL password
  --host=<host>                 Hostname for MySQL
  --port=<port>                 TCP port for MySQL
  --socket=<socket>             UNIX socket for MySQL
  --innodb_recover              Run InnoDB recovery on the writable snapshot (LVM2 only)
                                prior to performing the backup
  --lvcreate=<filename>         Path for lvcreate (def: $lvcreate)
  --lvremove=<filename>         Path for lvremove (def: $lvremove)
  --vgname=<name>               VG containing datadir (def: $vgname)
  --lvname=<name>               LV containing datadir (def: $lvname)
  --relpath=<name>              Relative path on LV to datadir (def: $relpath)
  --lvsize=<size>               Size for snapshot volume (def: $lvsize)
  --prefix=<prefix>             Prefix for naming the backup (def: $prefix)
  --datefmt=<format>            Specify the format of the date string (def: $datefmt)
  --mountdir=<dirname>          Path for mountpoint (def: $mountdir)
  --backupdir=<dirname>         Path for archives (def: $backupdir)
  --mount=<filename>            Path for mount (def: $mount)
  --umount=<filename>           Path for umount (def: $umount)
  --tar=<filename>              Path for tar (def: $tar)
  --xfs                         Use the "nouuid" mount option to safely mount XFS snapshots
  --log_method=<method>         How to log output from this script. Valid options are
                                "console", "syslog" or "both" (def: $log_method)
  --syslog_socktype=<type>      What type of socket to use for connecting to the syslog
                                service. Valid options are "native", "tcp" and "udp".
                                (def: $syslog_socktype)
  --syslog_facility=<facility>  Define a particular syslog facility (def: $syslog_facility)
  --syslog_remotehost=<host>    Host name of a remote syslog server (def: $syslog_remotehost)
  --configfile=<file>           Specify an alternative configuration file (def: $configfile)
  --help                        Print this help

If your MySQL daemon is not listening on localhost, or using the default 
socket location, you must specify --host or --socket.

EOF
 exit 1;
}

#
# Check if given directory exists and is writable
#
sub check_dir 
{
 my ($dirname,$optioname) = @_;
 unless ( (-d $dirname) and 
     (-w $dirname) and (-r $dirname) and  (-x $dirname))
 {
   print <<DIRERROR;

The directory $dirname does not exist or I don't have 
sufficient privileges to read/write/access it.
Please verify the permissions or provide another directory 
by using the option --$optioname=<directory>

DIRERROR

   log_msg ("The directory $dirname does not exist or I don't have sufficient privileges to read/write/access it.", LOG_ERR);

   &help;
  }
}  

#
# Sanitize directory names:
#
# 1. Remove any whitespace padding first
# 2. Remove trailing slashes
#
sub clean_dirname
{
 my ($d) = @_;
 $d =~ s/^\s*//g;
 $d =~ s/\s$//g;
 return File::Basename::dirname($d.'/foo')
}

sub lvm_version
{
  my $lv = `$lvs --version`;

  $lv =~ s/LVM version: //;
  $lv =~ s/^\s*//;
  $lv =~ s/\s.+//g;

  return $lv;
}

# vim: ts=2 sw=2 expandtab ft=perl:
